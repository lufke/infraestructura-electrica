import { SQLiteDatabase } from "expo-sqlite";
import { selectBuilder, updateBuilder } from "../database/builder";
import { supabase } from "../lib/supabase";

// Define table synchronization order (parents first)
const SYNC_ORDER = [
    "loteos",
    "soportes",
    "subestaciones",
    "postes",
    "camaras",
    "estructuras",
    "seccionamientos",
    "lineas_mt",
    "lineas_bt",
    "empalmes",
    "luminarias",
    "tirantes",
    "tierras"
];

// Map local foreign keys to their respective tables (for ID resolution)
const FK_MAP: Record<string, Record<string, string>> = {
    soportes: { id_loteo: "loteos" },
    postes: { id_soporte: "soportes" },
    camaras: { id_soporte: "soportes" },
    estructuras: { id_soporte: "soportes" },
    seccionamientos: { id_soporte: "soportes" },
    subestaciones: { id_soporte: "soportes" },
    lineas_mt: { id_soporte_inicio: "soportes", id_soporte_final: "soportes" },
    lineas_bt: { id_soporte_inicio: "soportes", id_soporte_final: "soportes", id_subestacion: "subestaciones" },
    empalmes: { id_soporte: "soportes", id_subestacion: "subestaciones" },
    luminarias: { id_empalme: "empalmes", id_soporte: "soportes" },
    tirantes: { id_soporte: "soportes" },
    tierras: { id_soporte: "soportes" }
};

/**
 * Get count of unsynced items per table
 */
export async function getUnsyncedCounts(db: SQLiteDatabase) {
    const results: Record<string, number> = {};

    for (const table of SYNC_ORDER) {
        const rows = await db.getAllAsync<{ count: number }>(
            `SELECT COUNT(*) as count FROM ${table} WHERE synced = 0`
        );
        results[table] = rows[0]?.count || 0;
    }

    return results;
}

/**
 * Synchronize database with Supabase
 * @param onProgress Callback (currentStep, totalSteps, message)
 */
export async function syncDatabase(
    db: SQLiteDatabase,
    onProgress?: (current: number, total: number, message: string) => void
) {
    const totalSteps = SYNC_ORDER.length;
    let currentStep = 0;

    for (const table of SYNC_ORDER) {
        currentStep++;
        if (onProgress) onProgress(currentStep, totalSteps, `Sincronizando ${table}...`);

        // 1. Get unsynced records
        const unsyncedRows: any[] = await selectBuilder(db, table, { synced: 0 });

        if (unsyncedRows.length === 0) continue;

        for (const row of unsyncedRows) {
            try {
                // 2. Prepare data for Supabase
                const dataToUpload = { ...row };

                // Remove local-only fields
                delete dataToUpload.id; // Supabase generates its own ID usually, or we use uuid. 
                // However, if we need to map relationships, we MUST resolve FKs first.
                delete dataToUpload.synced;
                delete dataToUpload.id_supabase; // We are creating it
                delete dataToUpload.created_at; // Optional: let server decide or keep local
                delete dataToUpload.updated_at;

                // 3. Resolve FKs
                // If this table has FKs, we need to swap local ID for id_supabase of the parent
                let fkError = false;
                if (FK_MAP[table]) {
                    for (const [fkCol, parentTable] of Object.entries(FK_MAP[table])) {
                        const localParentId = row[fkCol];
                        if (localParentId) {
                            // Find parent's supabase ID
                            const parentRow = await db.getFirstAsync<{ id_supabase: number }>(
                                `SELECT id_supabase FROM ${parentTable} WHERE id = ?`,
                                [localParentId]
                            );

                            if (parentRow?.id_supabase) {
                                dataToUpload[fkCol] = parentRow.id_supabase;
                            } else {
                                // Parent not synced yet, skipping this row for now
                                console.warn(`Skipping ${table} id=${row.id} because parent ${parentTable} id=${localParentId} is not synced.`);
                                fkError = true;
                                break;
                            }
                        }
                    }
                }

                if (fkError) continue;

                // 4. Upsert to Supabase
                // We assume the schema in Supabase matches. 
                // If 'id' is generated by Supabase, we insert and get back the new ID.
                const { data, error } = await supabase
                    .from(table)
                    .insert(dataToUpload)
                    .select("id")
                    .single();

                if (error) {
                    console.error(`Error syncing ${table} id=${row.id}:`, error);
                    continue;
                }

                if (data) {
                    // 5. Update local record with synced = 1 and id_supabase
                    await updateBuilder(db, table, row.id, {
                        synced: 1,
                        id_supabase: data.id
                    });
                }

            } catch (err) {
                console.error(`Exception syncing ${table} id=${row.id}:`, err);
            }
        }
    }
}
